
Observations:
When mutex init is created and it is now destroyed, it does not affect memomory or cause issues. 

You cannot unlock more than once, it will caise sanitizer errors.

Leaks: Each thread leaves 272 bytes of "Possibly lost", if not joined. 
		It seems like it can't be prevented with deatch.



Questions:
What is nr meals is 0? Should not start or ignore it?



What if a struct philo ph[i] is not passed as address into function, 
   how can you than use mutex_lock in this function with this philo ??
				mutex_lock(&philo->mutex_time)  with or without & ???


MYSLEEP() CAUSES THAT TIME IS UPDATED, SO IT NEVER DIES IN CASE OF SHORT TIMETODIE
NOW WITH USLEEP() I GET floating point exeption, WHEN IT SHOULD DIE 4 310 200 200 
PROBABLY THERE IS ALSO ISSUE WITH TIMER - HOW DOES IT KNOW WHICH PHILOSOPHER IS BEING CHECKED ???


About 10 milisecs later message:
	The subject that in case of death, message can have 10 milisecs delay.
		tteat   200
		ttsleep 200
		ttd     600

	started eating   at 1000,  deadline  1400
	started sleeping at 1200
	started thinking at 1400




MALLOCS:

philo_struct = malloc(sizeof(t_philo) * data->nrfilos);

d->mutex_forks = malloc(sizeof(pthread_mutex_t) * d->nrfilos);




